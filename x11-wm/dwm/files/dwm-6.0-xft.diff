diff --git a/dwm.c b/dwm.c
index 2e1b708..383cfd5 100644
--- a/dwm.c
+++ b/dwm.c
@@ -40,6 +40,7 @@
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
 #include <X11/XKBlib.h>
+#include <X11/Xft/Xft.h>
 
 /* macros */
 #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
@@ -119,16 +120,15 @@ struct Client {
 
 typedef struct {
     int x, y, w, h;
-    unsigned long norm[ColLast];
-    unsigned long sel[ColLast];
+    XftColor norm[ColLast];
+    XftColor sel[ColLast];
     Drawable drawable;
     GC gc;
     struct {
         int ascent;
         int descent;
         int height;
-        XFontSet set;
-        XFontStruct *xfont;
+        XftFont *xfont;
     } font;
 } DC; /* draw context */
 
@@ -206,8 +206,8 @@ static void die(const char *errstr, ...);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
-static void drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]);
-static void drawtext(const char *text, unsigned long col[ColLast], Bool invert);
+static void drawsquare(Bool filled, Bool empty, Bool invert, XftColor col[ColLast]);
+static void drawtext(const char *text, XftColor col[ColLast], Bool invert);
 static void enternotify(XEvent *e);
 static void expose(XEvent *e);
 static void focus(Client *c);
@@ -215,7 +215,7 @@ static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
-static unsigned long getcolor(const char *colstr);
+static XftColor getcolor(const char *colstr);
 static Bool getrootptr(int *x, int *y);
 static long getstate(Window w);
 static unsigned int getsystraywidth();
@@ -534,10 +534,6 @@ cleanup(void) {
     for(m = mons; m; m = m->next)
         while(m->stack)
             unmanage(m->stack, False);
-    if(dc.font.set)
-        XFreeFontSet(dpy, dc.font.set);
-    else
-        XFreeFont(dpy, dc.font.xfont);
     XUngrabKey(dpy, AnyKey, AnyModifier, root);
     XFreePixmap(dpy, dc.drawable);
     XFreeGC(dpy, dc.gc);
@@ -836,7 +832,7 @@ void
 drawbar(Monitor *m) {
     int x;
     unsigned int i, occ = 0, urg = 0;
-    unsigned long *col;
+    XftColor *col;
     Client *c;
 
     resizebarwin(m);
@@ -896,10 +892,10 @@ drawbars(void) {
 }
 
 void
-drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]) {
+drawsquare(Bool filled, Bool empty, Bool invert, XftColor col[ColLast]) {
     int x;
 
-    XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);
+    XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG].pixel);
     x = (dc.font.ascent + dc.font.descent + 2) / 4;
     if(filled)
         XFillRectangle(dpy, dc.drawable, dc.gc, dc.x+1, dc.y+1, x+1, x+1);
@@ -908,11 +904,12 @@ drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]) {
 }
 
 void
-drawtext(const char *text, unsigned long col[ColLast], Bool invert) {
+drawtext(const char *text, XftColor col[ColLast], Bool invert) {
     char buf[256];
     int i, x, y, h, len, olen;
+    XftDraw *d;
 
-    XSetForeground(dpy, dc.gc, col[invert ? ColFG : ColBG]);
+    XSetForeground(dpy, dc.gc, col[invert ? ColFG : ColBG].pixel);
     XFillRectangle(dpy, dc.drawable, dc.gc, dc.x, dc.y, dc.w, dc.h);
     if(!text)
         return;
@@ -927,11 +924,10 @@ drawtext(const char *text, unsigned long col[ColLast], Bool invert) {
     memcpy(buf, text, len);
     if(len < olen)
         for(i = len; i && i > len - 3; buf[--i] = '.');
-    XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);
-    if(dc.font.set)
-        XmbDrawString(dpy, dc.drawable, dc.font.set, dc.gc, x, y, buf, len);
-    else
-        XDrawString(dpy, dc.drawable, dc.gc, x, y, buf, len);
+    d = XftDrawCreate(dpy, dc.drawable, DefaultVisual(dpy, screen), DefaultColormap(dpy,screen));
+
+    XftDrawStringUtf8(d, &col[invert ? ColBG : ColFG], dc.font.xfont, x, y, (XftChar8 *) buf, len);
+    XftDrawDestroy(d);
 }
 
 void
@@ -977,7 +973,7 @@ focus(Client *c) {
         detachstack(c);
         attachstack(c);
         grabbuttons(c, True);
-        XSetWindowBorder(dpy, c->win, dc.sel[ColBorder]);
+        XSetWindowBorder(dpy, c->win, dc.sel[ColBorder].pixel);
         XkbLockGroup(dpy, XkbUseCoreKbd, c->XkbGroup);
         setfocus(c);
     }
@@ -1056,14 +1052,13 @@ getatomprop(Client *c, Atom prop) {
     return atom;
 }
 
-unsigned long
+XftColor
 getcolor(const char *colstr) {
-    Colormap cmap = DefaultColormap(dpy, screen);
-    XColor color;
+    XftColor color;
 
-    if(!XAllocNamedColor(dpy, cmap, colstr, &color, &color))
+    if(!XftColorAllocName(dpy, DefaultVisual(dpy, screen), DefaultColormap(dpy, screen), colstr, &color))
         die("error, cannot allocate color '%s'\n", colstr);
-    return color.pixel;
+    return color;
 }
 
 Bool
@@ -1173,35 +1168,12 @@ incnmaster(const Arg *arg) {
 
 void
 initfont(const char *fontstr) {
-    char *def, **missing;
-    int n;
+    if(!(dc.font.xfont = XftFontOpenName(dpy,screen,fontstr))
+    && !(dc.font.xfont = XftFontOpenName(dpy,screen,"fixed")))
+        die("error, cannot load font: '%s'\n", fontstr);
 
-    dc.font.set = XCreateFontSet(dpy, fontstr, &missing, &n, &def);
-    if(missing) {
-        while(n--)
-            fprintf(stderr, "dwm: missing fontset: %s\n", missing[n]);
-        XFreeStringList(missing);
-    }
-    if(dc.font.set) {
-        XFontStruct **xfonts;
-        char **font_names;
-
-        dc.font.ascent = dc.font.descent = 0;
-        XExtentsOfFontSet(dc.font.set);
-        n = XFontsOfFontSet(dc.font.set, &xfonts, &font_names);
-        while(n--) {
-            dc.font.ascent = MAX(dc.font.ascent, (*xfonts)->ascent);
-            dc.font.descent = MAX(dc.font.descent,(*xfonts)->descent);
-            xfonts++;
-        }
-    }
-    else {
-        if(!(dc.font.xfont = XLoadQueryFont(dpy, fontstr))
-        && !(dc.font.xfont = XLoadQueryFont(dpy, "fixed")))
-            die("error, cannot load font: '%s'\n", fontstr);
-        dc.font.ascent = dc.font.xfont->ascent;
-        dc.font.descent = dc.font.xfont->descent;
-    }
+    dc.font.ascent = dc.font.xfont->ascent;
+    dc.font.descent = dc.font.xfont->descent;
     dc.font.height = dc.font.ascent + dc.font.descent;
 }
 
@@ -1284,7 +1256,7 @@ manage(Window w, XWindowAttributes *wa) {
 
     wc.border_width = c->bw;
     XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-    XSetWindowBorder(dpy, w, dc.norm[ColBorder]);
+    XSetWindowBorder(dpy, w, dc.norm[ColBorder].pixel);
     configure(c); /* propagates border_width, if size doesn't change */
     updatewindowtype(c);
     updatesizehints(c);
@@ -1829,8 +1801,6 @@ setup(void) {
     dc.drawable = XCreatePixmap(dpy, root, DisplayWidth(dpy, screen), bh, DefaultDepth(dpy, screen));
     dc.gc = XCreateGC(dpy, root, 0, NULL);
     XSetLineAttributes(dpy, dc.gc, 1, LineSolid, CapButt, JoinMiter);
-    if(!dc.font.set)
-        XSetFont(dpy, dc.gc, dc.font.xfont->fid);
     /* init system tray */
     updatesystray();
     /* init bars */
@@ -1902,13 +1872,9 @@ tagmon(const Arg *arg) {
 
 int
 textnw(const char *text, unsigned int len) {
-    XRectangle r;
-
-    if(dc.font.set) {
-        XmbTextExtents(dc.font.set, text, len, NULL, &r);
-        return r.width;
-    }
-    return XTextWidth(dc.font.xfont, text, len);
+    XGlyphInfo ext;
+    XftTextExtentsUtf8(dpy, dc.font.xfont, (XftChar8 *) text, len, &ext);
+    return ext.xOff;
 }
 
 void
@@ -2019,7 +1985,7 @@ unfocus(Client *c, Bool setfocus) {
     if(!c)
         return;
     grabbuttons(c, False);
-    XSetWindowBorder(dpy, c->win, dc.norm[ColBorder]);
+    XSetWindowBorder(dpy, c->win, dc.norm[ColBorder].pixel);
     if(setfocus)
         XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 
@@ -2328,11 +2294,11 @@ updatesystray(void) {
         /* init systray */
         if(!(systray = (Systray *)calloc(1, sizeof(Systray))))
             die("fatal: could not malloc() %u bytes\n", sizeof(Systray));
-        systray->win = XCreateSimpleWindow(dpy, root, x, selmon->by, w, bh, 0, 0, dc.sel[ColBG]);
+        systray->win = XCreateSimpleWindow(dpy, root, x, selmon->by, w, bh, 0, 0, dc.sel[ColBG].pixel);
         wa.event_mask        = ButtonPressMask | ExposureMask;
         wa.override_redirect = True;
         wa.background_pixmap = ParentRelative;
-        wa.background_pixel  = dc.norm[ColBG];
+        wa.background_pixel  = dc.norm[ColBG].pixel;
         XSelectInput(dpy, systray->win, SubstructureNotifyMask);
         XChangeProperty(dpy, systray->win, netatom[NetSystemTrayOrientation], XA_CARDINAL, 32,
                 PropModeReplace, (unsigned char *)&systrayorientation, 1);
